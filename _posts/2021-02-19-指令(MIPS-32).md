---
layout: post
title:  "指令(MIPS-32)"
date:   2021-02-19 18:32:31 +0800
tags:
      - binary
---
# 指令(MIPS-32)
>计算机语言中的基本单词就是指令。

各种语言的指令集能体现出一定的相似性，因为所有计算机都是基于基本原理相似的硬件技术所构建的。计算机设计者致力于找到一种语言，既能方便硬件和编译器的设计，使性能达到最佳，又使成本和功耗最低。计组读了很久，沿着书中的习惯，详细的了解该指令集。

## 冯诺依曼体系结构
五大功能部件
* **输入设备**
* **输出设备**
* **运算器**
* **控制器**
* **存储器**：存储数据结构，下标从0开始的一维数组(抽象)

## MIPS-32指令集概况
* 32个寄存器，大小为32位。
* 2^30个存储器字，32位为一组。
* 字节编址，故需要遵照对齐限制(数据地址与存储器的自然边界对齐的需求)。
* 采用大端编址

## 单位与约定
* **字**：计算机中的基本访问单位，通常32位为一组，在MIPS体系结构中与寄存器大小相同。
* 变量对应的寄存器：$s0, $s1...
* 编译时的临时寄存器：$t0, $t1...
* $zero恒置为0，简化指令集。
## 助记符
**add**，**sub**，**addi**，**lw**，**sw**，**sll**，**srl**，**and**，**andi**，**or**，**ori**，**nor**
  
## 设计三原则
* 原则1：简单源于规整
* 原则2：越小越快
* 原则3：适宜的折中方案

## 指令的表示
指令在计算机内部是以若干或低或高的电信号序列表示的，形式上与数的表示相同。指令的布局形式叫作**指令格式**，MIPS指令占32位，与数据字的位数相等。

为了与汇编语言形成区分，我们把指令的数字形式称为**机器语言**，指令序列为**机器码**。

为了避免读写冗长的二进制字串，又由于几乎所有计算机的数据大小都是4的整数倍，因此流行用十六进制表示。

由于字段的限制，故设计者选择一条折中的限制，即保证所有指令长度相同，但不同类型的指令采用不同的指令格式。即
* **R型**：用于寄存器。
* **I型**：用于立即数。

### R型的字段表示(算术指令格式)

|op|rs|rt|rd|shamt|funct|
|----|----|----|----|----|----|
|6位|5位|5位|5位|5位|6位|

取字指令的常数被限制在32以内。

### I型的字段表示(数据传送指令格式)

|op|rs|rt|constant or address|
|----|----|----|:----:|
|6位|5位|5位|16位|

16位的地址字段允许取字指令取相对于基址寄存器地址偏移32768个字节范围内的任何数据字。

MIPS中各字段名称及含义如下：
* op：指令的基本操作，通常称为操作码。
* rs：第一个源操作数寄存器。
* rt：第二个源操作数寄存器。若是取数，则会用于指明接收取数结果的目的寄存器。
* rd：用于存放操作结果的目的寄存器。
* shamt：位移量，不使用该字段可置为0。
* funct：功能码，用于指明op字敦中操作的特定变式。

### MIPS指令编码

|指令|格式|op|rs|rt|rd|shamt|funct|address|
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|add|R|0|reg|reg|reg|0|32|no applicable|
|sub|R|0|reg|reg|reg|0|34|no applicable|
|addi|I|8|reg|reg|no applicable|no applicable|no applicable|常数|
|lw|I|35|reg|reg|no applicable|no applicable|no applicable|address|
|sw|I|43|reg|reg|no applicable|no applicable|no applicable|address|


因为几乎所有的指令都要用到寄存器，故必须有一套约定来将寄存器的名字映射为数字。如下表：
|寄存器名称|映射到的数字|
|----|----|
|$t0|8|
|$t1|9|
|$t2|10|
|$t3|11|
|$t4|12|
|$t5|13|
|$t6|14|
|$t7|15|
|$s0|16|
|$s1|17|
|$s2|18|
|$s3|19|
|$s4|20|
|$s5|21|
|$s6|22|
|$s7|23|

eg：将下列汇编语言翻译为机器语言
```mips
lw $t0, 1200($t1)
add $t0, $s2, $t0
sw $t0, 1200($t1)
```
先用十进制表示机器语言指令：
```mips
lw $t0, 1200($t1)
```
|op|rs|rt|constant or address|
|:----:|:----:|:----:|:----:|
|35|9|8|1200|
```mips
add $t0, $s2, $t0
```
|op|rs|rt|rd|shamt|funct|
|:----:|:----:|:----:|:----:|:----:|:----:|
|0|18|8|8|0|32|
```mips
sw $t0, 1200($t1)
```
|op|rs|rt|constant or address|
|:----:|:----:|:----:|:----:|
|43|9|8|1200|

再换算为二进制即可。

## 算术操作

### 算术运算指令
MIPS算术运算指令很严格，操作数必须来自寄存器
### add & sub
```mips
add a, b, c # a = b + c
```
如上的语句表达两个变量b和c相加，并将结果放置于变量a中。每条MIPS指令只执行一个操作，有且只有3个变量。如果想完成四个变量的相加就需要三条语句才能办到。减法同理，如下：
```mips
sub a, b, c # a = b - c
```
### 算术常数的运算指令addi
程序经常会在某个操作用到常数，例如将数组下标加1以指向下一个元素。若要使用常数，则需要将其从存储器中取出，效率会减慢。因此我们可以使用一个操作数是常数的算术操作指令，即加立即数(add immediate)，写成addi。
```mips
addi $s3, $s3, 4  # $s3 = $s3 + 4
```
由于MIPS支持负常数，故不需要设置减立即数的指令。

## 数据传送指令
处理器仅将少量数据存入寄存器中，而算术操作指令仅对寄存器进行操作，故为读取存储器的数据，就必须包含在存储器和寄存器之间传送数据的指令。

数据传送指令中的常量称为偏移量，存放基址的寄存器称为基址寄存器。

* 取数(load)：将数据从存储器复制到寄存器。
* 存数(store)：和取数相对。

为访问存储器的字，指令还要给出存储器的地址。由前可知，MIPS是按照字节编址，字的起始位置必须是4的倍数，故字节寻址也会影响数组的下标，与基址寄存器相加的偏移量必须是下标乘以4。
### lw & sw
eg：假设变量h存放在寄存器$s2中，数组A的基址放在$s3中，用MIPS汇编指令编译：A[12] = h + A[8]。
```mips
lw $t0, 32($s3) # gets A[8]
add $t0, $s2, $t0 # gets A[8] + h
sw $t0, 48($s3) # store h + A[8] in A[12]
```
lw和sw是MIPS体系结构中在存储器和寄存器之间复制字的指令，许多程序的变量个数要远多于寄存器的个数。编译器会将最常用的变量保存至寄存器中，若将不常使用的变量存回存储器的过程叫做寄存器溢出。由设计原则2，编译器必须高效利用寄存器。

## 逻辑操作
逻辑操作产生的目的是用于简化对字中若干位进行打包或者拆包的操作。

C，JAVA和MIPS的逻辑操作见下表：
|逻辑操作|C操作符|JAVA操作符|MIPS指令|
|:----:|:----:|:----:|:----:|
|左移|<<|<<|sll|
|右移|>>|>>>|srl|
|按位与|&|&|and, andi|
|按位或|\||\||or, ori|
|按位取反|-|-|nor|

### 移位
逻辑左移sll：
```mips
sll $t2, $s0, 4 # reg $t2 = reg $s0 << 4 bits
```
机器语言如下：
|op|rs|rt|rd|shamt|funct|
|:----:|:----:|:----:|:----:|:----:|:----:|
|0|0|16|10|4|0|

指令sll的编码在op字段和funct字段都为0，rd为10($t2)，rt为16($s0)，shamt为4，rs字段置为0。
### 按位与
两个操作位均为1时结果为1。
```mips
and $t0, $t1, $t2 # reg $t0 = reg $t1 & reg $t2
# $t2: 0000 0000 0000 0000 0000 1101 1100 0000
# $t1: 0000 0000 0000 0000 0011 1100 0000 0000
则$t0：0000 0000 0000 0000 0000 1100 0000 0000
```
>引出了掩码的概念。
### 按位或
两个操作位任意为1时结果为1。
```mips
or $t0, $t1, $t2 # reg $t0 = reg $t1 | reg $t2
# $t2: 0000 0000 0000 0000 0000 1101 1100 0000
# $t1: 0000 0000 0000 0000 0011 1100 0000 0000
则$t0：0000 0000 0000 0000 0011 1101 1100 0000
```
### 按位取反(NOR)
NOT仅有一个操作数，为保持三操作数的格式，引入了或非NOR来替代NOT，等价于：
```C
A NOR 0 = NOT(A OR 0) = NOT(A)
```
```mips
nor $t0, $t1, $t3 # reg $t0 = ~ (reg $t1 | reg $t3)
# $t3 = 0
则$t0：1111 1111 1111 1111 1100 0011 1111 1111
```
### 立即数与andi，立即数或ori
>在与立即数进行逻辑与操作和逻辑或操作时，立即数的高16位补0后形成32位常数进行计算，而作立即数加法时，需将立即数进行符号扩展。

## 决策指令
